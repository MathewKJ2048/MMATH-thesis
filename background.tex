%======================================================================
\chapter{Background}
%======================================================================


background - discuss formal verification, TLA+, Alloy, Dash, model-checking etc.

goal of the project:

\begin{enumerate}
	\item build a translator for Dash+ and Alloy
	\item evaluate performance
\end{enumerate}


%----------------------------------------------------------------------
\section{Configuration generation}
%----------------------------------------------------------------------


Objects whose value do not change over the model-checking are called CONSTANTS in TLA+. In general, these CONSTANTS are supposed to be given values in the .cfg file accompanying the .tla file fed into the TLC model checker. These objects correspond to instances generated by the Alloy Analyzer when a Dash+ model is run after translation to Alloy.

In <blast paper>, the authors introduce a tool called Blast, which enables the use of TLA+ to find these objects during the model-checking phase, rather that having the user set specific values manually in the .cfg file. They do this via the following method:

\begin{enumerate}
	\item The .tla file and .cfg file are augmented with annotations read by blast. These annotations determine the type and scope of the configurations to be tested
	\item Blast produces a modified .tla file and a modified .cfg file.
	\item For every CONSTANT $C$ in the original .tla file, there is added a VARIABLE $V_{C}$ in the modified .tla file. (CONSTANTS with no type annotations are ignored by blast)
	\item These variables are made to be unchangeable during the model-checking phase, using the UNCHANGED modifier in TLA+ (equivalent to writing $V_{C}' == V_{C}$).
	\item The type of the variable is added to the TypeOK relation in TLA+.
	\item The Init relation is modified by adding $V_{C} \in C$, where $C$ is now a CONSTANT whose value in the .cfg file is a set whose size is determined by the scope annotations read by blast.
\end{enumerate}

In summary, model-checking across multiple configurations is achieved by making these configurations valid initial states of the model being checked. After an initial state is chosen, the configuration remains unchanged when taking the Next transition in TLA+.


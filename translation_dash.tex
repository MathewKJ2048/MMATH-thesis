%======================================================================
\chapter{Translating Dash+ elements to TLA+}
%======================================================================

A Dash+ model is written with Alloy expressions and code embedded inside Dash structures. The Dash structures are used to model a transition system. Since TLA+ supports transitions natively, the dash elements are translated directly to TLA+, without an intermediate Alloy step.

Consider the following Dash model:

\begin{verbatim}
state root
{
	env event ee {}
	event ei {}
	default state s1{
		conc a {
			default state s1a1 {}
			state s1a2 {}
		}
		conc b {
			default state s1b1 {}
			state s1b2 {}
		}
	}
	state s2 {
		conc p {}
		conc q {}
	}
	trans t1 {
		from s1
		goto s2
	}
	trans t2 {
		on ee
		from s1a1
		goto s1b2
		send ei
	}
	trans t3 {
		from s1
		goto s1b1
	}
	trans t4 {
		from s1
		goto s1a1
	}
	trans t5 {
		from s1
		goto s1a2
	}
}
\end{verbatim}

This model is used to demonstrate the translation of following features of Dash:

\begin{itemize}
	\item State hierarchies
	\item Transitions
	\item Concurrency
	\item Big-step small-step semantics
	\item Internal and Environmental Events
\end{itemize}



%----------------------------------------------------------------------
\section{State Hierarchy}
%----------------------------------------------------------------------


The Dash model shown above has the following state hierarchy:

\begin{verbatim}
state root
{
	default state s1 {
		conc a {
			default state s1a1 {}
			state s1a2 {}
		}
		conc b {
			default state s1b1 {}
			state s1b2 {}
		}
	}
	state s2 {
		conc p {}
		conc q {}
	}
}
\end{verbatim}

There are three types of states in Dash:

\begin{itemize}
	\item Leaf states (s1a1, s1a2, s1b1, s1b2, p, q)
	\item OR states (root, a, b)
	\item AND states (s2, s1)
\end{itemize}

 During translation, every state is associated with a TLA definition, consisting of a set of strings. Each leaf-state is associated with a singleton set consisting of a string derived from the fully qualified name of the leaf-state, while non-leaf states are associated with sets made from the union of the sets associated with the leaf states that compose the non-leaf states.

\begin{verbatim}
_root_s1_b_s1b1 == {"root/s1/b/s1b1"}
_root_s1_b_s1b2 == {"root/s1/b/s1b2"}
_root_s1_a_s1a2 == {"root/s1/a/s1a2"}
_root_s1_a_s1a1 == {"root/s1/a/s1a1"}
_root_s2_q == {"root/s2/q"}
_root_s1_b == _root_s1_b_s1b1 \union _root_s1_b_s1b2
_root_s2_p == {"root/s2/p"}
_root_s1_a == _root_s1_a_s1a1 \union _root_s1_a_s1a2
_root_s2 == _root_s2_p \union _root_s2_q
_root_s1 == _root_s1_a \union _root_s1_b
_root == _root_s1 \union _root_s2
\end{verbatim}

Since TLA+ requires that a definition exists before it is used, the translator sorts the states in such a manner that a state is translated only after all the child states of that state is translated. Since the fully qualified names of a state is unique, no two states will be translated to TLA+ definitions of the same name.

\section{Dash variables}

The following variables are present in the .tla translation:

\begin{itemize}
	\item \_conf - this is a set of leaf state strings, representing the states that a snapshot is in
	\item \_trans\_taken - this is a string that holds the name of the transition taken to arrive at the current snapshot
	\item \_stable - this is a boolean value that is TRUE iff the current snapshot is stable
	\item \_scopes\_used - this is a set of leaf state strings, representing the scopes used in the current big step
	\item \_events - this is a set of events (represented as strings) that are active in the current snapshot
\end{itemize}

\begin{verbatim}
VARIABLES _trans_taken, _conf, _scopes_used, _stable, _events

\* string literal representations of transitions taken, which are the values taken by the _events variable
_root_ei == "root/ei"
_root_ee == "root/ee"
_environmental_events == {_root_ee}
_internal_events == {_root_ei}

\* string literal representations of transitions taken, which are the values taken by the _trans_taken variable
_taken_root_t2 == "root/t2"
_taken_root_t1 == "root/t1"
_taken_root_t4 == "root/t4"
_taken_root_t3 == "root/t3"
_taken_root_t5 == "root/t5"
_none_transition == "[none]"

\* state constraints
_valid_conf(arg) == arg \in _root_s2_p \union _root_s2_q \union _root_s1_a_s1a1 \union _root_s1_a_s1a2 \union _root_s1_b_s1b2 \union _root_s1_b_s1b1
_valid_trans_taken(arg) == arg \in {_taken_root_t2,_taken_root_t1,_taken_root_t4,_taken_root_t3,_taken_root_t5,_none_transition}
_valid_scopes_used(arg) == _valid_conf(arg)
_valid_stable(arg) == arg \in BOOLEAN
_valid_events(arg) == arg \in SUBSET (_environmental_events \union _internal_events)

_valid_unprimed == _valid_conf(_conf) /\ _valid_trans_taken(_trans_taken) /\ _valid_scopes_used(_scopes_used) /\ _valid_stable(_stable) /\ _valid_events(_events)

_valid_primed == _valid_conf(_conf') /\ _valid_trans_taken(_trans_taken') /\ _valid_scopes_used(_scopes_used') /\ _valid_stable(_stable') /\ _valid_events(_events')

_Init == _valid_unprimed
/\ _conf = _root_s1_a_s1a1 \union _root_s1_b_s1b1 
/\ _stable = TRUE 
/\ _scopes_used = {} 
/\ _trans_taken = _none_transition 
/\ _events \intersection _internal_events = {}

_Next == _valid_primed /\ _small_step

\end{verbatim}

Each transition and event has a formula with its fully qualified name as a string, which is used to assign values to \_trans\_taken and \_events, respectively. In addition to existing transitions, there is a default "[none]" string to represent stutter steps, where no transitions are taken. The use of square brackets prevent naming clashes with other transition names.

Since TLA+ requires that any formula involving a primed variable v start with a clause either of the form $v' \in exp$ or $v' = exp$, the formula \_valid\_primed is the first clause of \_Next. This allows a separation between the parts of the translation concerned with restricting the variables to valid values (\_valid\_primed), and the part of the translation that concerned with ensuring the variables values are correct (\_small\_step).

This is a departure from the translation to Alloy, and is required since TLA+ explores the set of all possible values for a variable. Without a validity constraint, the state space becomes infinite, and TLC cannot be run on the translation.

\subsection{Initial Values}

Since the first snapshot has no prior transition, the value assigned to \_trans\_taken in \_Init is \_none\_transition. Since the first snapshot is always stable, the value assigned to \_stable is TRUE, and to \_scopes\_used is the null set. Since internal events are generated by transitions, and no transition has been taken yet, there is a clause that states that no internal events are present in \_events.

The initial value of \_conf is determined by the following algorithm, executed during the translation.

\begin{itemize}
	\item Let $f(S)$ be the set of leaf states to be in, when starting at $S$ as the root state. $f(root)$ is the initial value of \_conf, where $root$ is the root state of the model.
	\item $f(S)= S$ if $S$ is itself a leaf state, with no children
	\item $f(S) = C_d$ if $S$ is an OR state, where $C_d$ is the default child state of $S$
	\item $f(S) = \bigcup_{i=1}^{n} f(C_i)$ if $S$ is an AND state
\end{itemize}

A possible alternate choice for such a translation involves the use of string literals for all states (leaf and non-leaf), with transitions written in such a way that the value of conf is always legal within the state hierarchy of the model. In such a scenario, the state of the model can be determined using only the set membership operator. The number of states that TLC needs to explore is a function of the semantics of the input model, and unaffected by the choice of representation of the states.

However, the amount of memory required to represent a particular configuration in the original scheme is less than or equal to the amount of memory needed to represent that configuration in the alternate scheme. All leaf states contribute a string literal to the conf set in both schemes, while non-leaf states contribute a string literal only in the alternate scheme. Since the memory used is lesser in the original scheme, we chose to base the translator design on it, instead of on the alternate scheme.



%----------------------------------------------------------------------
\section{Transitions}
%----------------------------------------------------------------------

Transitions are modelled as boolean formulae in TLA+. In Dash, the transitions are defined inside the state from which the transitions is taken. In the translation, all transitions are defined at the top-level. Each transition has the following:

\begin{itemize}
	\item (implicit) - the 'from' state
	\item goto - the 'to' state
	\item when - the guard, translated as an Alloy expression
	\item do - the action, translated as an Alloy expression
	\item on - the triggering event
	\item (emitting event - todo: fill this up post discussion)
\end{itemize}

Upon translation, each transition t has the following components, where t is the fully qualified name of the transition.

\begin{itemize}
	\item enabled\_t(\_arg\_scope\_used,\_arg\_events) - a boolean expression that is TRUE iff the transition can be taken with the values specified in the arguments
	\item pre\_t - pre-condition for the transition, describing the values of the unprimed variables
	\item post\_t - post-condition for the transition, describing the values of the primed variables
\end{itemize}

Consider a transition from the dash model:

\begin{verbatim}
trans t2 {
		on ee
		from s1a1
		goto s1b2
		send ei
	}
\end{verbatim}

This is translated into TLA+ as:

\begin{verbatim}
	\* parameterized formulae to check if transitions are enabled
	_enabled_root_t2(_arg_scopes_used,_arg_events) == TRUE

	// this is subject to changes
	_pre_root_t2 == _conf \intersect _root_s1_a_s1a1 /= {} 
	/\ _root \intersect _scopes_used = {} 
	/\ (IF _stable 
	THEN (_root_ee \in _events \intersect _environmental_events) 
	ELSE (_root_ee \in _events))
	_post_root_t2 == _trans_taken' = _taken_root_t2 
	/\ _conf' = (_conf \ (_root_s1_a_s1a1 \union _root_s1_a_s1a2 \union _root_s1_b_s1b1 \union _root_s1_b_s1b2)) \union _root_s1_a_s1a1 \union _root_s1_b_s1b2 
	/\ UNCHANGED <<_events>> 
	/\ UNCHANGED <<_scopes_used>> 
	/\ UNCHANGED <<_stable>>
	_root_t2 == _pre_root_t2 /\ _post_root_t2
\end{verbatim}



\begin{verbatim}
	VARIABLES _trans_taken

	_taken_root_t1 == "root/t1"
	_none_transition == "[none]"

	_pre_root_t1 == ((_conf \intersect [root/s1]) /= {})
	_post_root_t1 == (_trans_taken' = _taken_root_t1) /\ (_conf' = ((_conf \ {root/s1}) \union {root/s1}))
	_root_t1 == _pre_root_t1 /\ _post_root_t1

	_some_transition == _pre_root_t
	_some_pre_transition == _root_t
\end{verbatim}

Each transition is translated into the following elements:

\begin{itemize}
	\item \_taken\_[transition-name]
	\item \_pre\_[transition-name]
	\item \_post\_[transition-name]
	\item \_enabled\_[transition-name]
	\item \_[transition-name]
\end{itemize}

The transition is translated into a formula named after the fully qualified name of the transition, and is split into a pre-condition and a post-condition. The pre-conditions are used in \_some\_pre\_transition, which is the disjunction of all the preconditions, used to test if any transition is enabled.

\subsection{Transition Taken}

The \_taken\_[transition-name] refers to a definition of a string that represents the transition, obtained from the fully qualified name of the transition. The fully qualified name depends on the location of definition of the transition in the model, and is unique to the transition. 

When the transition is taken, the \_trans\_taken variable takes on the value of the string defined by \_taken\_[transition-name]. This does not affect the result obtained after running TLC on the translated model, and serves primarily as an aid to analyze traces produced by TLC. Since no transition is taken until the \_Next formula is true, the initial value of the \_trans\_taken variable is \_none\_transition, which defines a standard string that represents no transition.

\begin{verbatim}

	VARIABLES _trans_taken

	_taken_root_t == "root/t"
	_none_transition == "[none]"

	_all_trans_taken == {_taken_root_t,_none_transition}
	_TypeOK == (_trans_taken \in _all_trans_taken)

	_Init == _TypeOK /\ (_trans_taken = _none_transition)

\end{verbatim}

\subsection{Stability}

(Assumption: Big step and small step semantics explained in background)

Each snapshot is either stable or unstable, marking the start and end of a big step. The stability of the current snapshot is required to define the preconditions of transitions, while the postconditions determine the stability of the following snapshot. This is tracked using a boolean variable called \_stable.

\begin{verbatim}

	VARIABLES _stable

	_TypeOK == (_stable \in BOOLEAN)

	_Init == (_stable = TRUE)

\end{verbatim}

\subsection{Scopes}

Assumption: the term "scope" is explained in background

The scopes used up to the current snapshot is tracked using the \_scopes\_used variable. This variable has the same type as the \_conf variable, since there is a one-one correspondence between the set of scopes and the set of transitions. The \_scopes\_used variable is used when defining the preconditions to ensure that within a big step, only transitions in orthogonal scopes are taken. The value of the variable in the next snapshot is defined in the postconditions of the transitions.

\begin{verbatim}

	VARIABLES _scopes_used

	_all_scopes_used == _all_conf
	
	_TypeOK == (_scopes_used \subseteq _all_scopes_used)

	_Init == _TypeOK /\ (_scopes_used = {})

\end{verbatim}

\subsection{Stability after the transition}

To check whether a transition will be enabled for a given value of \_scopes\_used, a parameterized formula is associated with each transition, called \_enabled\_[transition-name]. When the next snapshot is stable, none of the transitions are enabled, which is represented by the \_next\_is\_stable formula. This is defined as the conjunction of the negations of the \_enabled\_[transition-name] formulae associated with each transition.

\begin{verbatim}

	_enabled_root_t(_arg_scopes_used) == // insert logic here

	// arguments change to include events later

	_next_is_stable(_arg_scopes_used) == ~(_enabled_root_t(_arg_scopes_used))

\end{verbatim}


\subsection{Stutter and small step}

A small step consists of the disjunction of all the transition formula, along with a stutter formula, where none of the variables change. Assumption: TLA+'s approach to stutter is explained, as is the separate mechanism to track inherent stutter in TLA+ vs explicit stutter. A stutter happens only when no other transitions are possible, which is determined using the \_next\_is\_stable formula.

\begin{verbatim}

	_some_transition == _pre_root_t
	_some_pre_transition == _pre_root_t
	_stutter == (_trans_taken' = _none_transition) /\ UNCHANGED <<_conf,_stable,_scopes_used>>
	_small_step == _some_transition \/ (_stutter /\ (~_some_pre_transition))

\end{verbatim}


Putting it all together, for a basic model with simple transitions and states, we have:

\begin{verbatim}

VARIABLES _trans_taken, _conf, _scopes_used, _stable

\* State literals, represented as sets of strings. Leaf-states become strings and non-leaf states are composed of their descendants
_root_s2 == {"root/s2"}
_root_s1 == {"root/s1"}
_root == _root_s1 \union _root_s2

\* string literal representations of transitions taken, which are the values taken by the _events variable

\* string literal representations of transitions taken, which are the values taken by the _trans_taken variable
_taken_root_t == "root/t"
_none_transition == "[none]"

\* parameterized formulae to check if transitions are enabled
_enabled_root_t(_arg_scopes_used) == TRUE

\* negation of disjunction of enabled-formulae
_next_is_stable(_arg_scopes_used) == ~(_enabled_root_t(_arg_scopes_used))

\* Translation of transition root/t
_pre_root_t == ((_conf \intersect [root/s1, root/s2]) /= {})
_post_root_t == (_trans_taken' = _taken_root_t) /\ (_conf' = ((_conf \ {root/s1,root/s2}) \union {root/s1,root/s2})) /\ UNCHANGED <<_scopes_used>> /\ UNCHANGED <<_stable>>
_root_t == _pre_root_t /\ _post_root_t

\* Small step definition
_some_transition == _pre_root_t
_some_pre_transition == _pre_root_t
_stutter == (_trans_taken' = _none_transition) /\ UNCHANGED <<_conf,_stable,_scopes_used>>
_small_step == _some_transition \/ (_stutter /\ (~_some_pre_transition))

\* type restrictions on variables
_all_conf == _root_s1 \union _root_s2
_all_trans_taken == {_taken_root_t,_none_transition}
_all_scopes_used == _all_conf
_TypeOK == (_conf \subseteq _all_conf) /\ (_stable \in BOOLEAN) /\ (_scopes_used \subseteq _all_scopes_used) /\ (_trans_taken \in _all_trans_taken)

\* initial values for variables
_Init == _TypeOK /\ (_conf = {}) /\ (_stable = TRUE) /\ (_scopes_used = {}) /\ (_trans_taken = _none_transition)

\* Next relation
_Next == _TypeOK /\ _small_step
====

\end{verbatim}


%----------------------------------------------------------------------
\section{Events}
%----------------------------------------------------------------------

This is a draft subject to rewrites:

This list is an outline of what to explain:

\begin{itemize}
	\item The events variable
	\item mapping the events to string forumale
	\item standard formulae for the set of internal events and the set of env events
	\item the use of filters using set intersection, to refer to internal events and environmental events in the transitions
	\item The policy used to clear the active events after big steps
	\item The mechanism used to prevent runaway cascades of repeated small steps taken endlessly
	\item non-determinism of which small step is taken in the event of multiple possible ones, though this is to be done in the background, and referred to here
\end{itemize}




%----------------------------------------------------------------------
\section{Actions}
%----------------------------------------------------------------------

Actions are translated from Alloy, and form boolean expressions which are integrated into the transition postconditions.

%----------------------------------------------------------------------
\section{Guards}
%----------------------------------------------------------------------

Actions are translated from Alloy, and form boolean expressions which are integrated into the transition preconditions.

%----------------------------------------------------------------------
\section{Notes (Ignore)}
%----------------------------------------------------------------------


fundamental features of dash:

description of a state hierarchy
description of transitions
initial constraints

States:
control states
OR states
AND states

OR and AND states have multiple child states
in an OR state, the system is in one or more of its child states

question: is it exclusive? no
paper clearly says one or more

priority is given for transitions that leave the parent state over those that leave the child state

what does this mean? if there is one transition that leaves to a different control state, what then?

AND state - in all of them, and their sub-states are independent

questions: AND state out of date, how t deal with citations for new stuff?


- conc 

question: enforcing the addition of multiple states or inference from just the leaf states


transition templates and add-ons - punt



A model - is it the description, or the series of snapshots?

Transitions take the model from one snapshot to the next

is there a canonical order to snapshots?


stable snapshot - no enabled transitions
enabled transition - one which has met guards and Events

unstable snapshot - not stable

big step - list of transitions from one stable snapshot to the next
small step - a single transition from an unstable snapshot
big step is also a list of small steps

Big step maximality: at most one transition per concurrent state

question: if big step maximality is enabled, is there a guarantee that all big-steps will be of finite length?

CONCURRENCY: says that a small step is a single transition


EVENT Lifeline: 
events last till the next big-step

variable lifeline:
variable changes are allowed to cascade through small steps

priority of transitions: leaving parent has priority over leaving child

question: can this affect which transitions are taken at all? yes, cancelling

Frame problem:
what si the equivalent in TLA+

non-determinism: same env input given in a big step can result in different ending snapshots

priority consistency

proving all of this formally



meta-question: does all this need full explanation


IMPORTANT: if nothing mentioned variable unchanged




